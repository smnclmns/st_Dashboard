
import requests
from ics import Calendar
from jinja2 import Template
from time import sleep
from datetime import datetime
import pytz
import os

# -- Helper functions --

def get_calender_from_url(url: str) -> Calendar:
    '''
    Returns a Calendar object from the given URL.
    The URL should be a string.
    If the URL is not a string, the function returns None.
    If the URL is not valid, the function raises an exception.
    If the URL is valid, the function returns a Calendar object.

    '''

    if not isinstance(url, str):
        return None
    
    ics_response = requests.get(url)
    ics_response.raise_for_status()

    for attempts in range(3):        

        try:
            cal = Calendar(ics_response.text)
        except Exception as e:
            print(f"Error: {e}")
            sleep(0.5)
            continue
    return cal

def _get_name_html(member: str, event_name: str) -> str:

    template_path = os.path.join(os.path.dirname(__file__), "name_template.html")

    with open(template_path, "r") as f:
        template = Template(f.read())
    return template.render(member=member, event_name=event_name)

def _get_title_html(event_name: str, member: str, start: str, end: str, location: str, des: str) -> str:

    template_path = os.path.join(os.path.dirname(__file__), "title_template.html")
    
    with open(template_path, "r") as f:
        template = Template(f.read())

    start_date, start_time = start.split("T")
    _, end_time = end.split("T")

    weekday = datetime.fromisoformat(start).strftime("%A")
    start_date = f"{weekday}, {start_date}"

    if des and len(des) > 25:
        des = des[:25] + "..."

    return template.render(
        event_name=event_name,
        member=member,
        start_date=start_date,
        start_time=start_time[:5],
        end_time=end_time[:5],
        location=location or "No Location",
        description=des or "No Description",
        )

def extract_calender_events(member: str, cal: Calendar) -> list[dict]:
    '''
    Returns a list of dictionaries with the event information for the timeline widget.
    The event information is:
    - id: The id of the event
    - content: The content of the event
    - start: The start date and time of the event
    - end: The end date and time of the event
    - group: The group of the event
    - title: The title of the event
    - style: The style of the event
    
    The event information is extracted from the calendar object.
    
    '''

    local_tz = pytz.timezone('Europe/Berlin')

    events = []
    for i, event in enumerate(cal.events):

        # Skip events that are already over
        if event.end.astimezone(local_tz).date() < datetime.now().date():
            continue

        # Skip events that are generated by Reclaim.ai
        if event.description and "Reclaim" in event.description:
            continue

        
        # Shift time by 2 hours -> GMT+2
        event.end = event.end.astimezone(local_tz)
        event.begin = event.begin.astimezone(local_tz)     

        # Convert Arrow-Objects in ISO 8601-Strings
        start = event.begin.isoformat()
        end = event.end.isoformat()

        # Create HTML-Content und Title
        content = _get_name_html(member, event.name)
        title = _get_title_html(event.name, member, start, end, event.location, event.description)

        # Set Style
        style = ""

        if event.description:
            if event.description == "Tamam":
                style += "border-color: gold; background-color: gold;"
        else:
            style += "border-color: grey; background-color: grey;"
        
        # Append Event-dict to List
        events.append({
            'id': f"{member}_{i}",
            'content': content,
            'start': start,
            'end': end,
            'group': member.split(' ')[0],
            'title': title,
            'style': style,
        })
    return events

def months_ahead(months_ahead: int) -> str:
    '''
    Returns the date of the current date plus the given number of months.
    '''
    
    # Convert months to number of years and months (e.g. 13 months -> 1 year and 1 month)
    year_ahead = months_ahead // 12
    months_ahead = months_ahead % 12
    # Calculate the maximum date
    replace_month = datetime.now().month + months_ahead
    if replace_month > 12:
        replace_month = replace_month % 12
        year_ahead += 1
    replace_year = datetime.now().year + year_ahead
    return f"{datetime.now().replace(year=replace_year, month=replace_month).isoformat()}"

def months_behind(months_behind: int) -> str:
    '''
    Returns the date of the current date minus the given number of months.
    '''
    # Convert months to number of years and months (e.g. 13 months -> 1 year and 1 month)
    year_behind = months_behind // 12
    months_behind = months_behind % 12
    # Calculate the minimum date
    replace_month = datetime.now().month - months_behind
    if replace_month < 1:
        replace_month = 12 + replace_month
        year_behind += 1
    replace_year = datetime.now().year - year_behind
    return f"{datetime.now().replace(year=replace_year, month=replace_month).isoformat()}"