My project:
`st_Dashboard/
    .env
    .gitattributes
    .gitignore
    convert_env_to_toml.py
    DirectoryContents.txt
    LICENSE
    main.py
    prompt.txt
    quick_scripts.ipynb
    README.md
    requirements.txt
    streamlit_app.py
    test.py
    .streamlit/
        secrets.toml
    custom_moduls/
        Connection_handling.py
        calender_widget/
            helper_functions.py
            name_template.html
            title_template.html
            __init__.py
            __pycache__/
                helper_functions.cpython-311.pyc
                __init__.cpython-311.pyc
        streamlit_timeline/
            __init__.py
            frontend/
                build/
                    asset-manifest.json
                    bootstrap.min.css
                    index.html
                    index_bk.html
                    precache-manifest.a632b80b25b19a605a90dd282a0397aa.js
                    service-worker.js
                    static/
                        css/
                            2.ab85016c.chunk.css
                            2.ab85016c.chunk.css.map
                            styles.css
                        js/
                            2.fc3cfd4b.chunk.js
                            2.fc3cfd4b.chunk.js.LICENSE.txt
                            2.fc3cfd4b.chunk.js.map
                            main.46d91172.chunk.js
                            main.46d91172.chunk.js.map
                            runtime-main.44d30fc2.js
                            runtime-main.44d30fc2.js.map
            styles/
                background.css
            __pycache__/
                __init__.cpython-311.pyc
        __pycache__/
            Connection_handling.cpython-311.pyc
    static/
        styles.css
        assets/
            Logo.png
    views/
        about_us.py
        tamam_calender.py`

C:\Users\simcl\Documents\GitHub\st_Dashboard\custom_moduls\calender_widget\helper_functions.py:
`
import requests
from ics import Calendar
from jinja2 import Template
from time import sleep
from datetime import datetime
import pytz


# -- Helper functions --

def get_calender_from_url(url: str) -> Calendar:
    '''
    Returns a Calendar object from the given URL.
    The URL should be a string.
    If the URL is not a string, the function returns None.
    If the URL is not valid, the function raises an exception.
    If the URL is valid, the function returns a Calendar object.

    '''

    if not isinstance(url, str):
        return None
    
    ics_response = requests.get(url)
    ics_response.raise_for_status()

    for attempts in range(3):        

        try:
            cal = Calendar(ics_response.text)
        except Exception as e:
            print(f"Error: {e}")
            sleep(0.5)
            continue
    return cal

def _get_name_html(member: str, event_name: str) -> str:
    with open("custom_moduls/calender_widget/name_template.html", "r") as f:
        template = Template(f.read())
    return template.render(member=member, event_name=event_name)

def _get_title_html(event_name: str, member: str, start: str, end: str, location: str, des: str) -> str:
    with open("custom_moduls/calender_widget/title_template.html", "r") as f:
        template = Template(f.read())

    start_date, start_time = start.split("T")
    _, end_time = end.split("T")

    weekday = datetime.fromisoformat(start).strftime("%A")
    start_date = f"{weekday}, {start_date}"

    if des and len(des) > 25:
        des = des[:25] + "..."

    return template.render(
        event_name=event_name,
        member=member,
        start_date=start_date,
        start_time=start_time[:5],
        end_time=end_time[:5],
        location=location or "No Location",
        description=des or "No Description",
        )

def extract_calender_events(member: str, cal: Calendar) -> list[dict]:
    '''
    Returns a list of dictionaries with the event information for the timeline widget.
    The event information is:
    - id: The id of the event
    - content: The content of the event
    - start: The start date and time of the event
    - end: The end date and time of the event
    - group: The group of the event
    - title: The title of the event
    - style: The style of the event
    
    The event information is extracted from the calendar object.
    
    '''

    local_tz = pytz.timezone('Europe/Berlin')

    events = []
    for i, event in enumerate(cal.events):

        # Skip events that are already over
        if event.end.astimezone(local_tz).date() < datetime.now().date():
            continue

        # Skip events that are generated by Reclaim.ai
        if event.description and "Reclaim" in event.description:
            continue

        
        # Shift time by 2 hours -> GMT+2
        event.end = event.end.astimezone(local_tz)
        event.begin = event.begin.astimezone(local_tz)     

        # Convert Arrow-Objects in ISO 8601-Strings
        start = event.begin.isoformat()
        end = event.end.isoformat()

        # Create HTML-Content und Title
        content = _get_name_html(member, event.name)
        title = _get_title_html(event.name, member, start, end, event.location, event.description)

        # Set Style
        style = ""

        if event.description:
            if event.description == "Tamam":
                style += "border-color: gold; background-color: gold;"
        else:
            style += "border-color: grey; background-color: grey;"
        
        # Append Event-dict to List
        events.append({
            'id': f"{member}_{i}",
            'content': content,
            'start': start,
            'end': end,
            'group': member.split(' ')[0],
            'title': title,
            'style': style,
        })
    return events

def months_ahead(months_ahead: int) -> str:
    '''
    Returns the date of the current date plus the given number of months.
    '''

    a = 1/months_ahead
    
    # Convert months to number of years and months (e.g. 13 months -> 1 year and 1 month)
    year_ahead = months_ahead // 12
    months_ahead = months_ahead % 12
    # Calculate the maximum date
    replace_month = datetime.now().month + months_ahead
    if replace_month > 12:
        replace_month = replace_month % 12
        year_ahead += 1
    replace_year = datetime.now().year + year_ahead
    return f"{datetime.now().replace(year=replace_year, month=replace_month).isoformat()}"

def months_behind(months_behind: int) -> str:
    '''
    Returns the date of the current date minus the given number of months.
    '''
    # Convert months to number of years and months (e.g. 13 months -> 1 year and 1 month)
    year_behind = months_behind // 12
    months_behind = months_behind % 12
    # Calculate the minimum date
    replace_month = datetime.now().month - months_behind
    if replace_month < 1:
        replace_month = 12 + replace_month
        year_behind += 1
    replace_year = datetime.now().year - year_behind
    return f"{datetime.now().replace(year=replace_year, month=replace_month).isoformat()}"`
C:\Users\simcl\Documents\GitHub\st_Dashboard\views\about_us.py:
`import streamlit as st
import os, re, traceback
from custom_moduls.calender_widget.helper_functions import months_ahead

def find_files_in_exception(exception):

    cwd = os.getcwd()
    root_folder = os.path.dirname(cwd)
    
    # Extract file paths from the exception message using regex
    file_paths_in_exception = re.findall(r'([a-zA-Z]:[\\\w.\\-]+|/[^:\s]+)', str(exception))

    files_in_exception = []
    
    for root, dirs, files in os.walk(cwd):
        for file in files:
            file_path = os.path.join(root, file)
            if any(file_path in path for path in file_paths_in_exception):

                files_in_exception.append(file_path)

    rel_file_paths = [path.split(root_folder, 1)[1] for path in files_in_exception]
    
    return files_in_exception

def get_file_contents(filepaths: list[str]) -> list[str]:

    file_contents = []
    for path in filepaths:
        with open(path, 'r') as f:
            file_contents.append(f.read())

    return file_contents

def list_cwd_contents():
    cwd = os.getcwd()
    contents = []
    for root, dirs, files in os.walk(cwd):
        if 'venv' in root or '.git' in root:
            continue
        level = root.replace(cwd, '').count(os.sep)
        indent = ' ' * 4 * (level)
        contents.append(f"{indent}{os.path.basename(root)}/")
        sub_indent = ' ' * 4 * (level + 1)
        for f in files:
            contents.append(f"{sub_indent}{f}")
    return "\n".join(contents)

def get_prompt(cwd_contents: str, files: list[str], file_contents: list[str], exception_msg: str):
    prompt = ""

    prompt += f"My project:\n`{cwd_contents}`\n\n"

    for file, content in zip(files, file_contents):

        prompt += f"{file}:\n`{content}`\n"

    prompt += f"Error:\n`{exception_msg}`"

    return prompt


st.write("This is the about us page.")

st.link_button("Google Sheet",st.session_state.ch.spreadsheet_url)

try:

    st.write(months_ahead(0))
except:
    files_in_exception = find_files_in_exception(traceback.format_exc())
    if files_in_exception:
        st.write(f"Exception occurred in the following files: {files_in_exception}")

        prompt = get_prompt(
            list_cwd_contents(),
            files_in_exception,
            get_file_contents(files_in_exception),
            traceback.format_exc())
        
        st.write(prompt)

        with open("prompt.txt", "w") as f:
            f.write(prompt)

    else:
        st.write(traceback.format_exc())
`
Error:
`Traceback (most recent call last):
  File "C:\Users\simcl\Documents\GitHub\st_Dashboard\views\about_us.py", line 69, in <module>
    st.write(months_ahead(0))
             ^^^^^^^^^^^^^^^
  File "C:\Users\simcl\Documents\GitHub\st_Dashboard\custom_moduls\calender_widget\helper_functions.py", line 134, in months_ahead
    a = 1/months_ahead
        ~^~~~~~~~~~~~~
ZeroDivisionError: division by zero
`